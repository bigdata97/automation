The End-to-End Story (day-in-the-life)

Enrollment lands
HR files (834/CSV/API) arrive for a new hire in Texas. Your ingest app validates the file, normalizes dates, and upserts:

Customer (the person and their addresses/IDs)

EnrolleeProducts (the person’s active plan/network/group with effective dates)

“Cardable change” detected (event/rules)
A rules service compares “before vs after.” New ACTIVE coverage or a plan/network/state change is cardable. It picks a Template based on LOB (Commercial), state (TX), group branding, and product type (PPO).

Build the render DTO
DTO Builder joins reference data (Plan, Benefits, Network, EmployerGroup, Control) with the member’s coverage to compute user-friendly lines like:
“PCP $25 | Spec $50 | ER $300 | UC $75” and “BIN 610591 | PCN ADV | Group RX123”.

Record the card
The service writes an IDCard document with a snapshot of the computed DTO and the chosen template/version. Status: QUEUED.

Batch & render
Nightly, the Batcher finds QUEUED IDCards, groups them into a PrintJob, renders front/back PDFs per template, packages a vendor file, sends to the print vendor (SFTP/API), and updates statuses along the way.

Digital instant card
At the same time the IDCard is created, a digital card URL is generated for the portal/app, so members can use it immediately—no need to wait for the mail.

Tracking & audit
Vendor confirms receipt → PrintJob status moves to SENT/CONFIRMED. Delivery scans can update IDCard to DELIVERED. Reprints later reuse the IDCard.render.dto snapshot to ensure exact replicas.


| Step                 | Reads                                                                           | Writes                                               | Purpose                                                   |
| -------------------- | ------------------------------------------------------------------------------- | ---------------------------------------------------- | --------------------------------------------------------- |
| Enrollment upsert    | EmployerGroup, Plan, Network (optional lookups to validate keys)                | **Customer**, **EnrolleeProducts**, (BillingAccount) | Establish the person and active coverage lines            |
| Rule/Template select | Customer, **EnrolleeProducts**, Plan, Network, EmployerGroup                    | —                                                    | Decide **if** a card is needed now and **which Template** |
| Build DTO            | **Benefits**, Plan, Network, EmployerGroup, Control, Customer, EnrolleeProducts | —                                                    | Compute human-readable lines for the card                 |
| Create card          | Template                                                                        | **IDCard** (with `render.dto`)                       | Persist immutable snapshot; set `status=QUEUED`           |
| Batch & render       | **IDCard** (QUEUED), Template                                                   | **PrintJob**, update **IDCard** statuses             | Package, send to vendor, track lifecycle                  |
| Digital card         | —                                                                               | update **IDCard.digitalCardUrl** (at creation time)  | Instant member access                                     |


1) Customer

Purpose: One doc per person (subscriber/dependent). Anchor for identity, address, and current coverages.

db.createCollection("Customer", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["orgId","person","identifiers","addresses","createdAt","updatedAt"],
      properties: {
        orgId: { bsonType: "string" },
        person: {
          bsonType: "object",
          required: ["firstName","lastName","dob"],
          properties: {
            firstName: { bsonType: "string" },
            lastName:  { bsonType: "string" },
            dob:       { bsonType: "date" }
          }
        },
        identifiers: {
          bsonType: "object",
          required: ["memberId"],
          properties: {
            memberId:   { bsonType: "string" },
            subscriberId:{ bsonType: "string" }
          }
        },
        addresses: {
          bsonType: "array",
          items: {
            bsonType: "object",
            required: ["type","line1","city","state","zip"],
            properties: {
              type: { enum: ["HOME","MAILING"] },
              line1:{ bsonType: "string" },
              city: { bsonType: "string" },
              state:{ bsonType: "string" },
              zip:  { bsonType: "string" },
              validated: { bsonType: "bool" }
            }
          }
        },
        coverages: {
          bsonType: "array",
          items: {
            bsonType: "object",
            required: ["enrolleeProductId","effectiveFrom","status"],
            properties: {
              enrolleeProductId: { bsonType: "objectId" },
              effectiveFrom: { bsonType: "date" },
              effectiveTo:   { bsonType: "date" },
              status: { enum: ["ACTIVE","PENDING","TERMINATED"] }
            }
          }
        },
        createdAt: { bsonType: "date" },
        updatedAt: { bsonType: "date" }
      }
    }
  }
})

db.Customer.createIndex({ orgId: 1, "identifiers.memberId": 1 }, { unique: true })
db.Customer.createIndex({ orgId: 1, "relationships.employerGroupId": 1 })
db.Customer.createIndex({ "person.lastName": 1, "person.firstName": 1, "person.dob": 1 })


2) EmployerGroup

Purpose: Group (sponsor) metadata: branding, group number, support contacts.

db.createCollection("EmployerGroup", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["orgId","groupNumber","name","createdAt","updatedAt"],
      properties: {
        orgId:       { bsonType: "string" },
        groupNumber: { bsonType: "string" },
        name:        { bsonType: "string" },
        branding: {
          bsonType: "object",
          properties: { logoRef: { bsonType: "string" }, colorHex: { bsonType: "string" } }
        },
        contact: {
          bsonType: "object",
          properties: { phone: { bsonType:"string" }, url: { bsonType:"string" } }
        },
        createdAt:   { bsonType: "date" },
        updatedAt:   { bsonType: "date" }
      }
    }
  }
})

db.EmployerGroup.createIndex({ orgId: 1, groupNumber: 1 }, { unique: true })

3) BillingAccount

Purpose: Subscriber billing context; can influence address/suppression rules.

db.createCollection("BillingAccount", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["orgId","accountNumber","status","createdAt","updatedAt"],
      properties: {
        orgId:         { bsonType: "string" },
        accountNumber: { bsonType: "string" },
        suffix:        { bsonType: "string" },
        status:        { enum: ["OPEN","CLOSED","SUSPENDED"] },
        preferences: {
          bsonType: "object",
          properties: { paperless: { bsonType:"bool" }, statementDay: { bsonType:"int" } }
        },
        createdAt:     { bsonType: "date" },
        updatedAt:     { bsonType: "date" }
      }
    }
  }
})

db.BillingAccount.createIndex({ orgId: 1, accountNumber: 1, suffix: 1 }, { unique: true })

4) Plan

Purpose: Product master—type (HMO/PPO), LOB, state. Drives template & compliance.

db.createCollection("Plan", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["orgId","planCode","name","lob","type","createdAt","updatedAt"],
      properties: {
        orgId:    { bsonType: "string" },
        planCode: { bsonType: "string" },
        name:     { bsonType: "string" },
        lob:      { enum: ["COMMERCIAL","MEDICARE","MEDICAID","EXCHANGE"] },
        type:     { enum: ["HMO","PPO","EPO","POS"] },
        state:    { bsonType: "string" },
        effectiveFrom: { bsonType: "date" },
        effectiveTo:   { bsonType: "date" },
        createdAt: { bsonType: "date" },
        updatedAt: { bsonType: "date" }
      }
    }
  }
})

db.Plan.createIndex({ orgId: 1, planCode: 1, state: 1, effectiveFrom: 1 })

5) Benefits

Purpose: What prints on the card (copays) + Rx routing (BIN/PCN/Group). Effective-dated by plan/network/state.

db.createCollection("Benefits", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["orgId","planId","copays","rx","effectiveFrom","createdAt","updatedAt"],
      properties: {
        orgId:   { bsonType: "string" },
        planId:  { bsonType: "objectId" },
        networkId: { bsonType: "objectId" },
        state:   { bsonType: "string" },
        copays: {
          bsonType: "object",
          properties: {
            pcp:        { bsonType: "string" },
            specialist: { bsonType: "string" },
            er:         { bsonType: "string" },
            urgentCare: { bsonType: "string" }
          }
        },
        rx: {
          bsonType: "object",
          properties: {
            bin:    { bsonType: "string" },
            pcn:    { bsonType: "string" },
            group:  { bsonType: "string" },
            issuer: { bsonType: "string" }
          }
        },
        coinsuranceText: { bsonType: "string" },
        effectiveFrom:   { bsonType: "date" },
        effectiveTo:     { bsonType: "date" },
        createdAt:       { bsonType: "date" },
        updatedAt:       { bsonType: "date" }
      }
    }
  }
})

db.Benefits.createIndex({ orgId: 1, planId: 1, networkId: 1, state: 1, effectiveFrom: 1 })

6) Network

Purpose: Provider network branding/aliases that appear on card.

db.createCollection("Network", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["orgId","code","name","createdAt","updatedAt"],
      properties: {
        orgId: { bsonType: "string" },
        code:  { bsonType: "string" },
        name:  { bsonType: "string" },
        printAliases: { bsonType: "array", items: { bsonType: "string" } },
        createdAt: { bsonType: "date" },
        updatedAt: { bsonType: "date" }
      }
    }
  }
})

db.Network.createIndex({ orgId: 1, code: 1 }, { unique: true })

7) EnrolleeProducts

Purpose: Effective-dated coverage row linking a Customer to Plan/Network/Group (and optional PCP).

db.createCollection("EnrolleeProducts", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["orgId","customerId","planId","effectiveFrom","status","createdAt","updatedAt"],
      properties: {
        orgId:      { bsonType: "string" },
        customerId: { bsonType: "objectId" },
        planId:     { bsonType: "objectId" },
        networkId:  { bsonType: "objectId" },
        groupId:    { bsonType: "objectId" },
        effectiveFrom: { bsonType: "date" },
        effectiveTo:   { bsonType: "date" },
        status:     { enum: ["ACTIVE","PENDING","TERMINATED"] },
        pcp: {
          bsonType: "object",
          properties: { npi: { bsonType: "string" }, name: { bsonType: "string" }, phone: { bsonType: "string" } }
        },
        createdAt:  { bsonType: "date" },
        updatedAt:  { bsonType: "date" }
      }
    }
  }
})

db.EnrolleeProducts.createIndex({ orgId: 1, customerId: 1, effectiveFrom: -1 })
db.EnrolleeProducts.createIndex({ orgId: 1, planId: 1, networkId: 1 })

8) Template

Purpose: Versioned card layout (front/back assets) + field bindings → DTO.

db.createCollection("Template", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["orgId","code","lob","state","version","fields","createdAt","updatedAt"],
      properties: {
        orgId:   { bsonType: "string" },
        code:    { bsonType: "string" },
        lob:     { enum: ["COMMERCIAL","MEDICARE","MEDICAID","EXCHANGE"] },
        state:   { bsonType: "string" },
        version: { bsonType: "int" },
        frontSvgRef: { bsonType: "string" },
        backSvgRef:  { bsonType: "string" },
        fields: {
          bsonType: "array",
          items: {
            bsonType: "object",
            required: ["key","x","y","font","binding"],
            properties: {
              key:     { bsonType: "string" },
              x:       { bsonType: "double" },
              y:       { bsonType: "double" },
              font:    { bsonType: "string" },
              binding: { bsonType: "string" } // JSONPath-like into render DTO
            }
          }
        },
        createdAt:{ bsonType: "date" },
        updatedAt:{ bsonType: "date" }
      }
    }
  }
})

db.Template.createIndex({ orgId: 1, code: 1, lob: 1, state: 1, version: -1 })

9) IDCard

Purpose: The card record + immutable render snapshot for audit/reprints; lifecycle status.

db.createCollection("IDCard", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["orgId","customerId","enrolleeProductId","templateId","status","render","createdAt","updatedAt"],
      properties: {
        orgId:            { bsonType: "string" },
        customerId:       { bsonType: "objectId" },
        enrolleeProductId:{ bsonType: "objectId" },
        templateId:       { bsonType: "objectId" },
        reason:           { enum: ["NEW_ENROLLMENT","REISSUE","ADDRESS_CHANGE","REPLACEMENT","RENEWAL"] },
        status:           { enum: ["QUEUED","RENDERED","SENT_TO_VENDOR","DELIVERED","FAILED"] },
        render: {
          bsonType: "object",
          required: ["dto","templateCode","templateVersion"],
          properties: {
            dto:             { bsonType: "object" },
            templateCode:    { bsonType: "string" },
            templateVersion: { bsonType: "int" },
            assetRefs:       { bsonType: "array", items: { bsonType: "string" } }
          }
        },
        digitalCardUrl: { bsonType: "string" },
        printJobId:     { bsonType: "objectId" },
        createdAt:      { bsonType: "date" },
        updatedAt:      { bsonType: "date" }
      }
    }
  }
})

db.IDCard.createIndex({ orgId: 1, customerId: 1, createdAt: -1 })
db.IDCard.createIndex({ orgId: 1, status: 1, createdAt: -1 })
db.IDCard.createIndex({ orgId: 1, printJobId: 1 })

10) PrintJob

Purpose: Operational batching/packaging and vendor handoff + confirmations.

db.createCollection("PrintJob", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["orgId","type","status","batchDate","createdAt","updatedAt"],
      properties: {
        orgId:   { bsonType: "string" },
        type:    { enum: ["BATCH","ON_DEMAND"] },
        status:  { enum: ["CREATED","PACKAGED","SENT","CONFIRMED","FAILED"] },
        batchDate: { bsonType: "date" },
        counts: {
          bsonType: "object",
          properties: { total: { bsonType:"int" }, failed: { bsonType:"int" } }
        },
        vendorFileRef: { bsonType: "string" },
        tracking: { bsonType: "object", properties: { vendorJobId: { bsonType:"string" } } },
        createdAt:{ bsonType: "date" },
        updatedAt:{ bsonType: "date" }
      }
    }
  }
})

db.PrintJob.createIndex({ orgId: 1, batchDate: -1, status: 1 })

11) Control

Purpose: Centralized config/compliance (payer ID, standard phones/URLs, disclaimers).

db.createCollection("Control", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["orgId","code","value","createdAt","updatedAt"],
      properties: {
        orgId: { bsonType: "string" },
        code:  { bsonType: "string" },   // e.g., "PAYER_ID", "SUPPORT_PHONE_DEFAULT", "TX_DISCLAIMER"
        value: { bsonType: "object" },   // arbitrary JSON payload
        effectiveFrom: { bsonType: "date" },
        effectiveTo:   { bsonType: "date" },
        createdAt: { bsonType: "date" },
        updatedAt: { bsonType: "date" }
      }
    }
  }
})

db.Control.createIndex({ orgId: 1, code: 1, effectiveFrom: -1 })

====================================================================

1) Customer

Stores person identity (name/DOB), unique member identifiers, and validated mailing addresses.
Anchors effective coverages via links to EnrolleeProducts; drives where the physical card is mailed.
Relates to EmployerGroup and BillingAccount for context; referenced by IDCard.

orgId

person.firstName

person.middleName

person.lastName

person.dob

person.gender

identifiers.memberId

identifiers.subscriberId

addresses[]

addresses[].type

addresses[].line1

addresses[].line2

addresses[].city

addresses[].state

addresses[].zip

addresses[].validated

relationships.employerGroupId

relationships.billingAccountId

coverages[]

coverages[].enrolleeProductId

coverages[].effectiveFrom

coverages[].effectiveTo

coverages[].status

createdAt

updatedAt

2) EmployerGroup

Holds group/sponsor details that influence branding, card text, and support contacts.
Group number on card helps providers route claims and identify the plan.
Referenced by Customer and EnrolleeProducts; indirectly influences Template selection.

orgId

groupNumber

name

branding.logoRef

branding.colorHex

contact.phone

contact.url

createdAt

updatedAt

3) BillingAccount

Represents subscriber billing context and preferences (paperless, statement timing).
May drive address or print suppression rules based on enterprise policies.
Linked from Customer; not usually printed but relevant to mail/ops logic.

orgId

accountNumber

suffix

status

preferences.paperless

preferences.statementDay

createdAt

updatedAt

4) Plan

Master product definition (HMO/PPO/EPO/POS), LOB, state, and effective ranges.
Plan metadata affects Template selection and compliance phrasing.
Referenced by EnrolleeProducts and Benefits to resolve what prints.

orgId

planCode

name

lob

type

state

effectiveFrom

effectiveTo

createdAt

updatedAt

5) Benefits

Card-facing copays and Rx routing (BIN/PCN/Group) scoped by plan/network/state.
Effective-dated so historical reprints reflect the exact terms at the time.
Joined by DTO builder using EnrolleeProducts → Plan/Network/State.

orgId

planId

networkId

state

copays.pcp

copays.specialist

copays.er

copays.urgentCare

coinsuranceText

rx.bin

rx.pcn

rx.group

rx.issuer

effectiveFrom

effectiveTo

createdAt

updatedAt

6) Network

Provider network brand and display aliases used on the printed card.
Helps providers recognize the member’s in-network access.
Referenced by EnrolleeProducts and Benefits for accurate branding.

orgId

code

name

printAliases[]

createdAt

updatedAt

7) EnrolleeProducts

Effective-dated enrollment line linking a Customer to Plan/Network/Group.
May include PCP info when required by product/state rules (often HMO).
Primary driver for “cardable” changes; referenced by Customer and IDCard.

orgId

customerId

planId

networkId

groupId

effectiveFrom

effectiveTo

status

pcp.npi

pcp.name

pcp.phone

createdAt

updatedAt

8) Template

Versioned front/back assets and field bindings that render the card.
Chosen by rule engine based on LOB/state/plan/group variants.
Referenced by IDCard; version locks for audit/reprints.

orgId

code

lob

state

version

frontSvgRef

backSvgRef

fields[]

fields[].key

fields[].x

fields[].y

fields[].font

fields[].binding

createdAt

updatedAt

9) IDCard

Authoritative card record with immutable render.dto snapshot for audit/reprints.
Tracks lifecycle status (QUEUED→RENDERED→SENT_TO_VENDOR→DELIVERED/FAILED).
Links to Customer, EnrolleeProducts, Template, and (later) PrintJob.

orgId

customerId

enrolleeProductId

templateId

reason

status

render.templateCode

render.templateVersion

render.dto

render.assetRefs[]

digitalCardUrl

printJobId

createdAt

updatedAt

10) PrintJob

Operational batch/on-demand package for vendor print submission.
Tracks counts, file references, and vendor confirmation/job IDs.
Referenced by IDCard to tie individual cards to the batch they shipped in.

orgId

type

status

batchDate

counts.total

counts.failed

vendorFileRef

tracking.vendorJobId

createdAt

updatedAt

11) Control

Centralized configuration and compliance text (payer IDs, phones, URLs, disclaimers).
Lets ops/compliance update messaging without code/template redeploys.
Read by DTO builder and renderer; influences what prints globally or per state.

orgId

code

value

effectiveFrom

effectiveTo

createdAt

updatedAt
